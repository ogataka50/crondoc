package main

import (
	"strings"
	"bufio"
	"fmt"
	"os"
	"io"
	"regexp"
	"unicode/utf8"
	flags "github.com/jessevdk/go-flags"
	//"github.com/k0kubun/pp"
)

// Exit codes are int values that represent an exit code for a particular error.
const (
	ExitCodeOK    int = 0
	ExitCodeError int = 1 + iota
)

// CLI is the command line object
type CLI struct {
	// outStream and errStream are the stdout and stderr
	// to write message from the CLI.
	outStream, errStream io.Writer
}

type CronDetail struct {
	commentOutLines	[]string
	titleLines		[]string
	authorLines		[]string
	paramLines		[]string
	cronLines		[]string
	envLines		[]string
}

var cronFormat = []string{"min", "hour", "day", "month", "day week"}

type cmdOptions struct {
//	tFilePath		string `short:"f" long:"file"`
	Stdin				bool `short:"s" long:"stdin"`
	Format				string `long:"format"`
	ExceptCommentOut	bool `short:"n"`
	Version				bool `short:"v" long:"version"`
	Help				bool `short:"h" long:"help"`
}


// Run invokes the CLI with the given arguments.
func (cli *CLI) Run(args []string) int {

	//get args,opt
	opts := &cmdOptions{}
	p := flags.NewParser(opts, flags.PrintErrors)
	p.Name = Name
	args, err := p.Parse()
	if err != nil {
		fmt.Print("Opt Parse Error\n")
		return ExitCodeError
	}

	if len(args) > 0 || opts.Stdin{
		var lines[] string
		//from stdin
		if opts.Stdin {
			lines = GetCronLines("")
		}
		//from file
		if len(args) > 0 {
			filePath := args[0]
			// if(filePath != "/etc/crontab"){
			// 	cronFormat = cronFormat[0:5]
			// }
			lines = GetCronLines(filePath)
		}
		//parse crontab
		cronDetails, commentOutDetails := ParseLines(lines)

		//TODO other format
		OutputMarkDown(cronDetails, commentOutDetails, opts.ExceptCommentOut)
		return ExitCodeOK
	}

	//version
	if opts.Version {
		fmt.Print(GetVersion())
		return ExitCodeOK
	}

	//help
	if opts.Help {
		fmt.Print(GetHelp())
		return ExitCodeOK
	}

	fmt.Print(GetHelp())
	return ExitCodeOK
}

//get crontab
func GetCronLines(filePath string) []string {

	var scanner *bufio.Scanner
	//file or Stdin
	if len(filePath) > 0 {
		var fp *os.File
		var err error
		//exist filapath
		_, err = os.Stat(filePath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "File %s not exist: %v\n", filePath, err)
			os.Exit(1)
		}
		//read file
		fp, err = os.Open(filePath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "File %s could not read: %v\n", filePath, err)
			os.Exit(1)
		}
		defer fp.Close()

		scanner = bufio.NewScanner(fp)
	}else{
		//read stdin
		scanner = bufio.NewScanner(os.Stdin)
	}

	lines	:= make([]string, 100)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	if err := scanner.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "scan error: %v\n", err)
		panic(err)
	}

	return lines
}

//crontab parse
func ParseLines(lines []string) ([]CronDetail, []CronDetail) {

	cronDetails := [] CronDetail{}
	commentOutDetails := [] CronDetail{}

	tmpLines := make([]string, 0)
	for i, _ := range lines {
		tmpLine := strings.TrimSpace(lines[i])
		if utf8.RuneCountInString(tmpLine) <= 0 {
			// To the group until Line break
			if len(tmpLines) > 0 {
				cronDetail := MakeCronDetail(tmpLines)
				if len(cronDetail.cronLines) > 0 || len(cronDetail.envLines) > 0 {
					cronDetails = append(cronDetails, cronDetail)
				}else{
					commentOutDetails = append(commentOutDetails, cronDetail)
				}
				tmpLines = make([]string, 0)
			}
		}else{
			tmpLines = append(tmpLines, tmpLine)
		}
	}
	return cronDetails, commentOutDetails
}


func MakeCronDetail(tmpLines []string) CronDetail {

	var cronDetail CronDetail

	for i, _ := range tmpLines {
		bool, _ := regexp.MatchString("^#", strings.TrimSpace(tmpLines[i]))
		if bool {
			boolTitle,	_	:= regexp.MatchString("@title", tmpLines[i])
			boolAuthor,	_	:= regexp.MatchString("@author", tmpLines[i])
			boolParam,	_	:= regexp.MatchString("@param", tmpLines[i])
			//Divided into each tag
			if boolTitle {
				cronDetail.titleLines = append(cronDetail.titleLines, tmpLines[i])
			} else if boolAuthor {
				cronDetail.authorLines = append(cronDetail.authorLines, tmpLines[i])
			}else if boolParam{
				cronDetail.paramLines = append(cronDetail.paramLines, tmpLines[i])
			}else{
				cronDetail.commentOutLines = append(cronDetail.commentOutLines, tmpLines[i])
			}
		}else if boolEnv, _ := regexp.MatchString("(^SHELL|^PATH|^MAILTO|^HOME)", strings.TrimSpace(tmpLines[i])); boolEnv {
			cronDetail.envLines = append(cronDetail.envLines, tmpLines[i])
		}else{
			cronDetail.cronLines = append(cronDetail.cronLines, tmpLines[i])
		}
	}

	return cronDetail
}

func OutputMarkDown(cronDetails []CronDetail, commentOutDetails []CronDetail, ExceptCommentOut bool){
	fmt.Print("# effective crontab\n\n")
	MarkDownCronDoc(cronDetails)

	if !ExceptCommentOut {
		fmt.Print("# commentout crontab\n\n")
		MarkDownCronDoc(commentOutDetails)
	}

	fmt.Print("\n\ngenerated by crondoc")
}

func MarkDownCronDoc(cronDetails []CronDetail ) {
	for i, _ := range cronDetails {
		//title line
		for j, _ := range cronDetails[i].titleLines {
			pos := strings.Index(cronDetails[i].titleLines[j], "@title") + len("@title")
			fmt.Printf("## %s\n\n", strings.TrimSpace(cronDetails[i].titleLines[j][pos:]))
		}
		//author line
		for j, _ := range cronDetails[i].authorLines {
			pos := strings.Index(cronDetails[i].authorLines[j], "@author") + len("@author")
			fmt.Printf("- Author : %s\n", strings.TrimSpace(cronDetails[i].authorLines[j][pos:]))
		}
		//param line
		for j, _ := range cronDetails[i].paramLines {
			pos := strings.Index(cronDetails[i].paramLines[j], "@param") + len("@param")
			fmt.Printf("- Param : %s\n", strings.TrimSpace(cronDetails[i].paramLines[j][pos:]))
		}
		//comment outed
		if len(cronDetails[i].commentOutLines) > 0 {
			for j, _ := range cronDetails[i].commentOutLines {
				rep := regexp.MustCompile(`^#+`)
				cronDetails[i].commentOutLines[j] = rep.ReplaceAllString(cronDetails[i].commentOutLines[j], "")
				fmt.Printf(" - %s\n", strings.TrimSpace(cronDetails[i].commentOutLines[j]))
			}
		}
		//env setting
		if len(cronDetails[i].envLines) > 0 {
			fmt.Print("### Environment variable\n\n")
			for j, _ := range cronDetails[i].envLines {
				fmt.Printf(" - %s\n", strings.TrimSpace(cronDetails[i].envLines[j]))
			}
		}
		//cron setting
		if len(cronDetails[i].cronLines) > 0 {
			//command header
			var tmpFormat string
			for _, val := range cronFormat {
				tmpFormat = tmpFormat + val + "|"
			}
			fmt.Printf("\n| %scommand |\n", tmpFormat)
			fmt.Print("|:---|:---|:---|:---|:---|:---|\n")
			for j, _ := range cronDetails[i].cronLines {
				//fmt.Printf("%s\n", strings.TrimSpace(cronDetails[i].cronLines[j]))
				rep := regexp.MustCompile(`( |\t)+`)
				arrCommand := rep.Split(strings.TrimSpace(cronDetails[i].cronLines[j]), 6)
				for k, _ := range arrCommand {
					if len(cronFormat) > k {
						if k == 4 {
							//day of week
							resStr := ReplaceDayOfWeek(arrCommand[k])
							fmt.Printf("| %s", strings.TrimSpace(resStr))
						}else{
							fmt.Printf("| %s", strings.TrimSpace(arrCommand[k]))
						}
					}else{
						fmt.Printf("| `%s` |\n", strings.TrimSpace(arrCommand[k]))
					}
				}
			}
		}

		fmt.Print("\n\n***\n\n")
	}
}

// replace number -> day of week
func ReplaceDayOfWeek(str string) string {
	r := strings.NewReplacer("0","Sun", "1", "Mon", "2", "Tue", "3", "Wed", "4", "Thu", "5", "Fri", "6", "Sat", "7", "Sun")
	resStr := r.Replace(str)

	return resStr
}

func GetHelp() string {
	helpText := `
usage: crondoc [OPTIONS] <args> crontab_path

argument
	generate crontab document from <args> crontab_path

Available options are:
	-v --version		print versions
	-h --help		print help
	-s --stdin		generate crontab document from stdin
	-n			except output comment out line
`
	return strings.TrimSpace(helpText)
}

func GetVersion() string {
	versionText := Name + " version " + Version
	return strings.TrimSpace(versionText)
}
